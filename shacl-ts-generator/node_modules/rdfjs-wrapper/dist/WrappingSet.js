import { TermWrapper } from "./TermWrapper.js";
export class WrappingSet {
    subject;
    predicate;
    valueMapping;
    termMapping;
    // TODO: Direction
    constructor(subject, predicate, valueMapping, termMapping) {
        this.subject = subject;
        this.predicate = predicate;
        this.valueMapping = valueMapping;
        this.termMapping = termMapping;
    }
    add(value) {
        this.subject.dataset.add(this.quad(value));
        return this;
    }
    clear() {
        for (const q of this.matches) {
            this.subject.dataset.delete(q);
        }
    }
    delete(value) {
        if (!this.has(value)) {
            return false;
        }
        const o = this.termMapping(value, this.subject.dataset, this.subject.factory)?.term; // TODO: guards
        const p = this.subject.factory.namedNode(this.predicate);
        for (const q of this.subject.dataset.match(this.subject.term, p, o)) {
            this.subject.dataset.delete(q);
        }
        return true;
    }
    forEach(cb, thisArg) {
        for (const item of this) {
            cb.call(thisArg, item, item, this);
        }
    }
    has(value) {
        return this.subject.dataset.has(this.quad(value));
    }
    get size() {
        return this.matches.size;
    }
    [Symbol.iterator]() {
        return this.values();
    }
    *entries() {
        for (const v of this) {
            yield [v, v];
        }
    }
    keys() {
        return this.values();
    }
    *values() {
        for (const q of this.matches) {
            yield this.valueMapping(new TermWrapper(q.object, this.subject.dataset, this.subject.factory));
        }
    }
    get [Symbol.toStringTag]() {
        return `collection wrapper for subject ${this.subject} predicate ${this.predicate}`; // TODO: Direction
    }
    quad(value) {
        const s = this.subject.term; // TODO: guard
        const p = this.subject.factory.namedNode(this.predicate);
        const o = this.termMapping(value, this.subject.dataset, this.subject.factory)?.term; // TODO: guards
        const q = this.subject.factory.quad(s, p, o);
        return q;
    }
    get matches() {
        const p = this.subject.factory.namedNode(this.predicate);
        return this.subject.dataset.match(this.subject.term, p);
    }
}
//# sourceMappingURL=WrappingSet.js.map