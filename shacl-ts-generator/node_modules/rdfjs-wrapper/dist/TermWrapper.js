import { WrappingSet } from "./WrappingSet.js";
export class TermWrapper {
    term;
    dataset;
    factory;
    constructor(term, dataset, factory) {
        if (typeof term === "string") {
            this.term = factory.namedNode(term);
        }
        else {
            this.term = term;
        }
        this.dataset = dataset;
        this.factory = factory;
    }
    singular(p, valueMapping) {
        const predicate = this.factory.namedNode(p);
        const matches = this.dataset.match(this.term, predicate);
        // TODO: Expose standard errors
        if (matches.size > 1) {
            throw new Error(`More than one value for predicate ${p} on term ${this.term.value}`);
        }
        for (const q of matches) {
            return valueMapping(new TermWrapper(q.object, this.dataset, this.factory));
        }
        throw new Error(`No value found for predicate ${p} on term ${this.term.value}`);
    }
    singularNullable(p, valueMapping) {
        const predicate = this.factory.namedNode(p);
        for (const q of this.dataset.match(this.term, predicate)) {
            return valueMapping(new TermWrapper(q.object, this.dataset, this.factory));
        }
        return;
    }
    overwrite(p, value, nodeMapping) {
        if (value === undefined) {
            throw new Error("value cannot be undefined");
        }
        this.overwriteNullable(p, value, nodeMapping);
    }
    overwriteNullable(p, value, termMapping) {
        const predicate = this.factory.namedNode(p);
        for (const q of this.dataset.match(this.term, predicate)) {
            this.dataset.delete(q);
        }
        // TODO: TermMapping undefined: Return after deleting quads if undefined
        if (value === undefined) {
            return;
        }
        // TODO: Do we really need to test if this.term is a Quad Subject here?
        // @Samu I imagine this is tested at instantiation time in the constructor if at all
        if (!TermWrapper.isQuadSubject(this.term)) {
            return; // TODO: throw error?
        }
        // TODO: TermMapping undefined: the term mapping is not invoked if undefined
        const o = termMapping(value, this.dataset, this.factory);
        if (o === undefined) {
            return; // TODO: throw error?
        }
        if (!TermWrapper.isQuadObject(o.term)) {
            return; // TODO: throw error?
        }
        const q = this.factory.quad(this.term, predicate, o.term);
        this.dataset.add(q);
    }
    objects(p, valueMapping, termMapping) {
        return new WrappingSet(this, p, valueMapping, termMapping);
    }
    static isQuadSubject(term) {
        return ["NamedNode", "BlankNode", "Quad", "Variable"].includes(term.termType);
    }
    static isQuadObject(term) {
        return ["NamedNode", "Literal", "BlankNode", "Quad", "Variable"].includes(term.termType);
    }
}
//# sourceMappingURL=TermWrapper.js.map