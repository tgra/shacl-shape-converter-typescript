import { IndexerInterceptor } from "./IndexerInterceptor.js";
import { ListItem } from "./ListItem.js";
import { RDF } from "./vocabulary/RDF.js";
import { Overwriter } from "./Overwriter.js";
export class RdfList {
    subject;
    predicate;
    valueMapping;
    termMapping;
    root;
    constructor(root, subject, predicate, valueMapping, termMapping) {
        this.subject = subject;
        this.predicate = predicate;
        this.valueMapping = valueMapping;
        this.termMapping = termMapping;
        this.root = new ListItem(root, this.subject.dataset, this.subject.factory, valueMapping, termMapping);
        // TODO: Singleton interceptor?
        return new Proxy(this, new IndexerInterceptor);
    }
    get [Symbol.unscopables]() {
        return Array.prototype[Symbol.unscopables];
    }
    get length() {
        return [...this.items].length;
    }
    set length(_) {
        throw new Error("this array is based on an RDF Collection. Its length cannot be modified like this.");
    }
    [Symbol.iterator]() {
        return this.values();
    }
    at(index) {
        // TODO: Don't materialize all, only up to index
        return [...this.items].at(index)?.first;
    }
    concat(...items) {
        return [...this].concat(...items);
    }
    copyWithin(target, start, end) {
        throw new Error("not implemented");
    }
    entries() {
        // TODO: Don't materlialize all upfront
        return [...this].entries();
    }
    every(predicate, thisArg) {
        return [...this].every(predicate, thisArg);
    }
    fill(value, start, end) {
        throw new Error("not implemented");
    }
    filter(predicate, thisArg) {
        return [...this].filter(predicate, thisArg);
    }
    find(predicate, thisArg) {
        return [...this].find(predicate, thisArg);
    }
    findIndex(predicate, thisArg) {
        return [...this].findIndex(predicate, thisArg);
    }
    flat(depth) {
        throw new Error("not implemented");
    }
    flatMap(callback, thisArg) {
        return [...this].flatMap(callback, thisArg);
    }
    forEach(callback, thisArg) {
        [...this].forEach(callback, thisArg);
    }
    includes(searchElement, fromIndex) {
        return [...this].includes(searchElement, fromIndex);
    }
    indexOf(searchElement, fromIndex) {
        return [...this].indexOf(searchElement, fromIndex);
    }
    join(separator) {
        return [...this].join(separator);
    }
    keys() {
        // TODO: Don't materialize all upfront
        return [...this.items].keys();
    }
    lastIndexOf(searchElement, fromIndex) {
        return [...this].lastIndexOf(searchElement, fromIndex);
    }
    map(callback, thisArg) {
        return [...this].map(callback, thisArg);
    }
    pop() {
        return [...this.items].at(-1)?.pop();
    }
    push(...items) {
        const nil = this.subject.factory.namedNode(RDF.nil);
        for (const item of items) {
            // A node will be needed either to replace rdf:nil in an empty list or to add a new one to the end of an existing list
            const newNode = new ListItem(this.subject.factory.blankNode(), this.subject.dataset, this.subject.factory, this.valueMapping, this.termMapping);
            const lastNode = this.root.isNil ?
                // The statement representing an empty list is replaced by a new one whose object is the new node
                // The representation of the first item (root, currently rdf:nil, the empty list) is overwritten by the new node
                this.root = new Overwriter(this.subject, this.predicate).listNode = newNode :
                // replace rest of current last with new and return is because it's the new last
                [...this.items].at(-1).rest = newNode;
            lastNode.first = item;
            lastNode.restRaw = nil;
        }
        return this.length;
    }
    reduce(callback, initialValue) {
        return [...this].reduce(callback, initialValue);
    }
    reduceRight(callback, initialValue) {
        return [...this].reduceRight(callback, initialValue);
    }
    reverse() {
        throw new Error("not implemented");
    }
    shift() {
        if (this.root.isNil) {
            return undefined;
        }
        const value = this.root.first;
        if (this.root.rest.isNil) {
            new Overwriter(this.subject, this.predicate).listNode = this.root.rest;
            this.root.firstRaw = undefined;
            this.root.restRaw = undefined;
        }
        else {
            this.root.firstRaw = this.root.rest.firstRaw;
            this.root.restRaw = this.root.rest.restRaw;
        }
        return value;
    }
    slice(start, end) {
        // TODO: Probably no need to materialize all
        return [...this].slice(start, end);
    }
    some(predicate, thisArg) {
        return [...this].some(predicate, thisArg);
    }
    sort(compareFn) {
        throw new Error("not implemented");
    }
    splice(start, deleteCount, ...items) {
        throw new Error("not implemented");
    }
    unshift(...items) {
        for (const item of items.reverse()) {
            const firstNode = this.root;
            this.root = new Overwriter(this.subject, this.predicate).listNode = new ListItem(this.subject.factory.blankNode(), this.subject.dataset, this.subject.factory, this.valueMapping, this.termMapping);
            this.root.first = item;
            this.root.rest = firstNode;
        }
        return this.length;
    }
    *values() {
        for (const item of this.items) {
            yield item.first;
        }
    }
    get items() {
        return this.root.items();
    }
}
//# sourceMappingURL=RdfList.js.map